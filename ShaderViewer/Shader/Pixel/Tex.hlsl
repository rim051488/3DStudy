struct PSInput {
	float4 svpos:SV_POSITION;
	float4 pos:POSITION;
	float3 norm:NORMAL;
	float2 uv:TECOORD;
	float4 diff:COLOR0;
	float4 spec:COLOR1;
};

// ディレクションライト用の定数バッファ
cbuffer DirectionLightCb : register(b1)
{
	float3 ligDirection;	//ライトの方向
	float3 ligColor;		//ライトのカラー
}

cbuffer BaseCBuffer : register(b0) {
	matrix AntiViewportM;//4x4ビューポート逆行列
	matrix ProjectionM;//4x4プロジェクション行列
	float4x3 ViewM;//4x3(ビュー行列)
	float4x3 LocalM;//4x3(回転拡縮平行移動)
	float4		ToonOutLineSize;						// トゥーンの輪郭線の大きさ
	float		DiffuseSource;							// ディフューズカラー( 0.0f:マテリアル  1.0f:頂点 )
	float		SpecularSource;						// スペキュラカラー(   0.0f:マテリアル  1.0f:頂点 )
	float		MulSpecularColor;						// スペキュラカラー値に乗算する値( スペキュラ無効処理で使用 )
	float		Padding;//詰め物(無視)
}

struct MaterialBuffer
{
	float4 diff;			// ディフューズカラー
	float4 spec;			// スペキュラカラー
	float4 ambi;			// エミッシブ + アンビエント + グローバルアンビエント
	float power;			// スペキュラの強さ
	float3 pad;				// パディング
};

SamplerState sam:register(s0);
sampler Toon:register(s1);
Texture2D<float4> tex:register(t0);
Texture2D<float4> toon:register(t1);


float4 main(PSInput input) : SV_TARGET
{
	// ↓色が変わるだけでテクスチャ関係なし
	//return float4(0.0f, 1.0f, 1.0f, 1.0f);
	//return float4(0,0,1,1);
	// ↓テクスチャを貼り付けるだけ
	//return float4(input.uv,1,1);
	return tex.Sample(sam,float2(input.uv.xy));

}